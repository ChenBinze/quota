额度管理系统设计：
1、定义额度信息组成：设计最细力度是买家+额度币种+额度类型，例如买家人民币维度信用卡额度；另外增加金额、状态等状态；

2、额度操作组成：初始化+额度新增+额度扣减+额度查询，其中初始化/额度新增/额度扣减为同个接口及方法，根据操作类型路由
2.1、额度初始化：关键字段校验，其中额度金额必须大于等于0，不传默认为0；额度信息表新增一条数据，流水表新增一条申请流水记录；
需要进行唯一约束校验，若存在拦截；并发情况下通过唯一约束拦截，如果情况多的话可以加redis分布式锁，减少db压力；
2.2、额度新增：申请金额必须大于0；额度信息表更新数据金额数据，流水表新增额度增加流水；操作时需要对额度信息表加行锁，控制并发资金风险；
扩展：可以根据额度状态情况控制是否允许额度新增
2.3、额度扣减：申请金额必须大于0，并且不能大于数据库当前额度，即扣减操作不能使额度为负数，即额度超用。其他类额度新增
2.4、额度查询：分为list全部查询以及分页查询，本次设计查询必须传入clientId，原因是用户额度信息比较敏感，基于安全考虑，不做全数据展示，
只能查指定用户的；当然也可根据管理员权限不同额外定制，例如超级管理员可以分页查全量数据，本次设计不考虑。

3、定时任务逻辑：只做新增或者扣减，例如根据一些账单解析后生成的任务明细
考虑2点：
一是处理速度要快，并且减少对同条额度信息并发操作导致抢表锁失败；
二是任务失败需要重试，但是要做重试时间分级，例如未处理过的任务数据5分钟捞取一次，执行过1次失败需要再重试的10分钟捞取一次，
执行过2次失败需要再重试的15分钟捞取一次等等；重试失败到达一定次数后停止重试，并且需要告警出来，人工介入。

如何设计：本次设计了重试次数的能力，但是根据不同失败次数分级重试的任务不一一写了
数据量大，机器部署多zone，分库分表情况下可以考虑三层分发逻辑，这里不详细描述了；本次设计为先load数据，再split分组，最后异步线程处理。
具体逻辑：
每次捞取100条数据，根据clientId + quotaType + currency分组（额度信息表的唯一约束），组与组之间使用线程池异步并行操作，
同组里面的数据同线程内串行执行，操作成功后删除任务明细数据，操作失败的话任务明细数据重试次数+1；
异步并行操作为了加快速度，分组为了避免多笔任务数据操作同一个额度信息数据抢锁，导致部分抢锁失败走到了下一级的失败重试任务，反而更慢了。
